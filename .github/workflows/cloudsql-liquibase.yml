name: Liquibase to CloudSQL PostgreSQL with Script rollback

on:
  workflow_dispatch:
  push:
    paths:
      - 'db/changesets/datastore/cloudsql/**'
      - '.github/workflows/cloudsql-liquibase.yml'

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      PROJECT_ID: autodeploydb
      CLOUDSQL_INSTANCE: us-central1:poc-dbtools
      CLOUDSQL_DATABASE: poc_liquibase
      CLOUDSQL_USER: ${{ secrets.CLOUDSQL_DEPLOY_USER }}
      CLOUDSQL_PASSWORD: ${{ secrets.CLOUDSQL_DEPLOY_PASSWORD }}
      GCP_SA_KEY: ${{ secrets.CLOUDSQL_SA_KEY }}
      # For private IP instances, set to 'true'
      USE_PRIVATE_IP: 'false'
      DRY_RUN_ENABLED: 'true'
      LB_TAG: run-${{ github.run_id }}-${{ github.run_attempt }}
      LB_DRIVER: org.postgresql.Driver
      LB_CHANGELOG: db/changelog.xml
      LB_PROPERTIES: db/config/liquibase.properties
      LB_LOG_LEVEL: info
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Prepare folders
        run: mkdir -p lib

      - name: Download Liquibase CLI
        run: |
          curl -L -o "$RUNNER_TEMP/liquibase.zip" https://github.com/liquibase/liquibase/releases/download/v4.29.2/liquibase-4.29.2.zip
          unzip -q "$RUNNER_TEMP/liquibase.zip" -d "$HOME/liquibase"
          chmod +x "$HOME/liquibase/liquibase"
          echo "LB=$HOME/liquibase/liquibase" >> "$GITHUB_ENV"

      - name: Download PostgreSQL JDBC driver
        run: |
          curl -L -o lib/postgresql-42.7.1.jar https://repo1.maven.org/maven2/org/postgresql/postgresql/42.7.1/postgresql-42.7.1.jar

      - name: Setup Cloud SQL Auth Proxy
        if: env.USE_PRIVATE_IP == 'true'
        run: |
          curl -o cloud-sql-proxy https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.8.0/cloud-sql-proxy.linux.amd64
          chmod +x cloud-sql-proxy
          echo "PROXY_PATH=$PWD/cloud-sql-proxy" >> "$GITHUB_ENV"

      - name: Write service account key & set path
        run: |
          echo '${{ env.GCP_SA_KEY }}' > "$RUNNER_TEMP/sa.json"
          # Verify the JSON is valid
          if ! jq empty "$RUNNER_TEMP/sa.json" 2>/dev/null; then
            echo "Invalid JSON in service account key"
            exit 1
          fi
          echo "SA_KEY_PATH=$RUNNER_TEMP/sa.json" >> "$GITHUB_ENV"
 
      - name: Start Cloud SQL Proxy (for private IP)
        if: env.USE_PRIVATE_IP == 'true'
        run: |
          export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          $PROXY_PATH --port 5432 --private-ip "${PROJECT_ID}:${CLOUDSQL_INSTANCE}" --debug &
          echo "PROXY_PID=$!" >> "$GITHUB_ENV"
          
          # Wait for proxy with better error handling
          for i in {1..60}; do  # Increased from 30
            if nc -z localhost 5432; then
              echo "Cloud SQL Proxy is ready"
              # Test actual authentication
              if PGPASSWORD="$CLOUDSQL_PASSWORD" timeout 10 psql -h localhost -p 5432 -U "$CLOUDSQL_USER" -d "$CLOUDSQL_DATABASE" -c "SELECT 1;" 2>/dev/null; then
                echo "Database authentication successful"
                break
              else
                echo "Proxy running but authentication failed, continuing to wait..."
              fi
            fi
            echo "Waiting for Cloud SQL Proxy... ($i/60)"
            sleep 3  # Increased from 2
          done
          
          # Final verification
          sleep 10  # Increased stabilization time
      
      - name: Install Cloud SQL JDBC Socket Factory (for public IP)
        if: env.USE_PRIVATE_IP == 'false'
        run: |
          # Download with verification and retry
          for i in {1..3}; do
            echo "Download attempt $i/3"
            if curl -L --fail -o lib/postgres-socket-factory-1.15.0-jar-with-dependencies.jar \
              https://repo1.maven.org/maven2/com/google/cloud/sql/postgres-socket-factory/1.15.0/postgres-socket-factory-1.15.0-jar-with-dependencies.jar; then
              
              # Verify the JAR is valid
              if jar tf lib/postgres-socket-factory-1.15.0-jar-with-dependencies.jar > /dev/null 2>&1; then
                echo "JAR downloaded and verified successfully"
                break
              else
                echo "JAR verification failed, retrying..."
                rm -f lib/postgres-socket-factory-1.15.0-jar-with-dependencies.jar
              fi
            else
              echo "Download failed, retrying..."
            fi
            
            if [ $i -eq 3 ]; then
              echo "Failed to download valid JAR after 3 attempts"
              exit 1
            fi
            sleep 2
          done
      
          # Update classpath to include socket factory
          shopt -s nullglob
          jars=("$GITHUB_WORKSPACE"/lib/*.jar)
          CLASSPATH=$(IFS=:; echo "${jars[*]}")
          echo "CLASSPATH=$CLASSPATH" >> "$GITHUB_ENV"
          
          # Set up service account authentication for socket factory
          export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"      
      
      - name: Debug connection (test with psql)
        if: env.USE_PRIVATE_IP == 'true'
        run: |
          # Install PostgreSQL client
          sudo apt-get update && sudo apt-get install -y postgresql-client
          
          # Test basic connection
          echo "Testing basic connection..."
          PGPASSWORD="$CLOUDSQL_PASSWORD" psql -h localhost -p 5432 -U "$CLOUDSQL_USER" -d "$CLOUDSQL_DATABASE" -c "SELECT version();" || echo "Connection test failed"

      - name: Build classpath and Liquibase config
        id: classpath
        run: |
          set -euo pipefail
          shopt -s nullglob
          jars=("$GITHUB_WORKSPACE"/lib/*.jar)
          if [ ${#jars[@]} -eq 0 ]; then
            echo "ERROR: No JARs found in $GITHUB_WORKSPACE/lib"
            echo "FAILURE_STEP=Build classpath - JAR discovery" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=No JAR files found in lib directory" >> "$GITHUB_ENV"
            exit 1
          fi
          CLASSPATH=$(IFS=:; echo "${jars[*]}")
          echo "CLASSPATH=$CLASSPATH" >> "$GITHUB_ENV"
          echo "Using CLASSPATH: $CLASSPATH"
          
          # Build connection URL based on connection type
          if [ "$USE_PRIVATE_IP" = "true" ]; then
            LB_URL="jdbc:postgresql://localhost:5432/${CLOUDSQL_DATABASE}?sslmode=disable&connectTimeout=60&socketTimeout=60&loginTimeout=60&tcpKeepAlive=true"
          else
            LB_URL="jdbc:postgresql://google/${CLOUDSQL_DATABASE}?cloudSqlInstance=${PROJECT_ID}:${CLOUDSQL_INSTANCE}&socketFactory=com.google.cloud.sql.postgres.SocketFactory&sslmode=disable&connectTimeout=60&socketTimeout=60&tcpKeepAlive=true"
          fi   
          echo "LB_URL=$LB_URL" >> "$GITHUB_ENV"
          
          # Build Liquibase command
          if [ -f "$LB_PROPERTIES" ]; then
            LB_BASE_CMD="\"$LB\" --driver=\"$LB_DRIVER\" --classpath=\"$CLASSPATH\" --url=\"$LB_URL\" --username=\"$CLOUDSQL_USER\" --password=\"$CLOUDSQL_PASSWORD\" --changeLogFile=\"$LB_CHANGELOG\" --defaultsFile=\"$LB_PROPERTIES\" --log-level=\"$LB_LOG_LEVEL\""
          else
            LB_BASE_CMD="\"$LB\" --driver=\"$LB_DRIVER\" --classpath=\"$CLASSPATH\" --url=\"$LB_URL\" --username=\"$CLOUDSQL_USER\" --password=\"$CLOUDSQL_PASSWORD\" --changeLogFile=\"$LB_CHANGELOG\" --log-level=\"$LB_LOG_LEVEL\""
          fi
          
          # Guard + sanitized echo
          if ! echo "$LB_BASE_CMD" | grep -q -- '--password='; then
            echo "FAILURE_STEP=Command assembly" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=Missing --password flag in LB_BASE_CMD" >> "$GITHUB_ENV"
            exit 1
          fi
          echo "LB_BASE_CMD=$(echo "$LB_BASE_CMD" | sed 's/--password=\"[^\"]*\"/--password=\"***\"/')" >> "$GITHUB_ENV"
          
          echo "Liquibase configuration ready"

      - name: Sanity check repo files
        run: |
          pwd
          ls -la
          ls -la db
          ls -la db/config
          
          # Check for liquibase.properties
          if [ -f "$LB_PROPERTIES" ]; then
            echo "Found liquibase.properties:"
            cat "$LB_PROPERTIES"
          else
            echo "No liquibase.properties file found"
          fi
          
          echo "LB_URL=$LB_URL"
          echo "About to run: $(echo "$LB_BASE_CMD" | sed 's/--password=\"[^\"]*\"/--password=\"***\"/') validate"

      - name: Validate changelog
        id: validate
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          if ! eval "$LB_BASE_CMD validate"; then
            echo "FAILURE_STEP=Changelog validation" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=Changelog XML validation failed - check syntax and structure" >> "$GITHUB_ENV"
            exit 1
          fi

      - name: Check pending changes
        id: pending_changes
        run: |
          set -euo pipefail
          
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          if ! STATUS_OUTPUT=$(eval "$LB_BASE_CMD status" 2>&1); then
            echo "FAILURE_STEP=Database connection check" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=Unable to connect to CloudSQL or retrieve status" >> "$GITHUB_ENV"
            echo "ERROR_OUTPUT=$STATUS_OUTPUT" >> "$GITHUB_ENV"
            exit 1
          fi
          
          echo "Status output:"
          echo "$STATUS_OUTPUT"
          
          if echo "$STATUS_OUTPUT" | grep -qE "changeset(s)? (has|have) not been applied"; then
            echo "has_pending_changes=true" >> "$GITHUB_OUTPUT"
            echo "Pending changes detected"
          else
            echo "has_pending_changes=false" >> "$GITHUB_OUTPUT"
            echo "No pending changes"
          fi

      - name: Dry run (updateSQL)
        if: env.DRY_RUN_ENABLED == 'true' && steps.pending_changes.outputs.has_pending_changes == 'true'
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          if ! eval "$LB_BASE_CMD --output-file=\"liquibase_update_${LB_TAG}.sql\" updateSQL"; then
            echo "FAILURE_STEP=Dry run SQL generation" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=updateSQL command failed - check changesets for SQL syntax errors" >> "$GITHUB_ENV"
            exit 1
          fi

      - name: Upload updateSQL artifact
        if: env.DRY_RUN_ENABLED == 'true' && steps.pending_changes.outputs.has_pending_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: "updateSQL-${{ env.LB_TAG }}"
          path: "**/liquibase_update_*.sql"

      - name: Tag pre-deploy state
        id: tag_predeploy
        if: steps.pending_changes.outputs.has_pending_changes == 'true'
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          if ! eval "$LB_BASE_CMD tag \"${LB_TAG}\""; then
            echo "FAILURE_STEP=Pre-deployment tagging" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=Failed to create rollback tag ${LB_TAG}" >> "$GITHUB_ENV"
            exit 1
          fi
          
          echo "tagged=true" >> "$GITHUB_OUTPUT"
          echo "tag_name=$LB_TAG" >> "$GITHUB_OUTPUT"

      - name: Update (apply pending changes)
        id: lb_update
        if: steps.pending_changes.outputs.has_pending_changes == 'true'
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          # Capture the specific changeset that fails
          UPDATE_OUTPUT=""
          if ! UPDATE_OUTPUT=$(eval "$LB_BASE_CMD update" 2>&1); then
            
            echo "Update failed - capturing failure details..."
            
            # Extract failing changeset from Liquibase output
            FAILING_CHANGESET=$(echo "$UPDATE_OUTPUT" | grep -oE "changeset.*failed" | head -1 || echo "Unknown changeset")
            FAILING_SQL=$(echo "$UPDATE_OUTPUT" | grep -A 5 -B 5 "ERROR" | head -10 || echo "SQL error details not captured")
            
            echo "FAILURE_STEP=Liquibase update execution" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=Failed at: $FAILING_CHANGESET" >> "$GITHUB_ENV"
            echo "FAILING_SQL<<EOF" >> "$GITHUB_ENV"
            echo "$FAILING_SQL" >> "$GITHUB_ENV"
            echo "EOF" >> "$GITHUB_ENV"
            
            echo "Executing immediate rollback to ${LB_TAG}"
            
            if ! ROLLBACK_OUTPUT=$(eval "$LB_BASE_CMD rollback --tag=\"${LB_TAG}\"" 2>&1); then
                echo "FAILURE_STEP=Critical: Rollback failed after update failure" >> "$GITHUB_ENV"
                echo "FAILURE_DETAILS=Database may be in inconsistent state. Manual intervention required." >> "$GITHUB_ENV"
                echo "ROLLBACK_ERROR<<EOF" >> "$GITHUB_ENV"
                echo "$ROLLBACK_OUTPUT" >> "$GITHUB_ENV"
                echo "EOF" >> "$GITHUB_ENV"
                exit 1
            fi
            
            echo "Rollback completed successfully"
            exit 1
          fi
          
          echo "All changesets applied successfully"

      - name: Post-deploy verification
        if: steps.lb_update.outcome == 'success'
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          echo "Verifying deployment..."
          
          if ! eval "$LB_BASE_CMD status --verbose"; then
            echo "FAILURE_STEP=Post-deployment verification" >> "$GITHUB_ENV"
            echo "FAILURE_DETAILS=Deployment succeeded but verification failed" >> "$GITHUB_ENV"
            exit 1
          fi
          
          echo "Deployment verification completed successfully"

      - name: Rollback on workflow failure (safety net)
        if: failure() && steps.tag_predeploy.outputs.tagged == 'true' && steps.lb_update.outcome != 'failure'
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          echo "Workflow failed outside of update step - executing safety rollback"
          echo "Rolling back to tag: ${{ steps.tag_predeploy.outputs.tag_name }}"
          
          if ! SAFETY_ROLLBACK=$(eval "$LB_BASE_CMD rollback --tag=\"${{ steps.tag_predeploy.outputs.tag_name }}\"" 2>&1); then
              echo "FAILURE_STEP=Safety net rollback failure" >> "$GITHUB_ENV"
              echo "FAILURE_DETAILS=Manual intervention required - rollback failed" >> "$GITHUB_ENV"
              echo "SAFETY_ROLLBACK_ERROR<<EOF" >> "$GITHUB_ENV"
              echo "$SAFETY_ROLLBACK" >> "$GITHUB_ENV"
              echo "EOF" >> "$GITHUB_ENV"
              exit 1
          fi
          
          echo "Safety net rollback completed"

      - name: Release Liquibase locks
        if: always()
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          eval "$LB_BASE_CMD releaseLocks" || echo "Failed to release locks (may not exist)"

      - name: Stop Cloud SQL Proxy
        if: always() && env.USE_PRIVATE_IP == 'true'
        run: |
          if [ -n "${PROXY_PID:-}" ]; then
            kill $PROXY_PID || echo "Proxy already stopped"
          fi

      - name: Final status check
        if: always()
        run: |
          if [ "$USE_PRIVATE_IP" != "true" ]; then
            export GOOGLE_APPLICATION_CREDENTIALS="$SA_KEY_PATH"
          fi
          
          echo "Final database status:"
          eval "$LB_BASE_CMD status --verbose" || echo "Status check failed"

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: ${{ env.LB_TAG }}" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudSQL Instance**: ${{ env.CLOUDSQL_INSTANCE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Database**: ${{ env.CLOUDSQL_DATABASE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Connection Type**: ${{ env.USE_PRIVATE_IP == 'true' && 'Private IP (via Proxy)' || 'Public IP (Socket Factory)' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Pending Changes**: ${{ steps.pending_changes.outputs.has_pending_changes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tagged for Rollback**: ${{ steps.tag_predeploy.outputs.tagged }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Update Status**: ${{ steps.lb_update.outcome }}" >> $GITHUB_STEP_SUMMARY
          
          # Display failure details if any step failed
          if [ -n "${FAILURE_STEP:-}" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ❌ Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "- **Failed Step**: ${{ env.FAILURE_STEP }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Failure Details**: ${{ env.FAILURE_DETAILS }}" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "${ERROR_SUGGESTION:-}" ]; then
              echo "- **Suggested Fix**: ${{ env.ERROR_SUGGESTION }}" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ -n "${CLOUDSQL_ERROR:-}" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### CloudSQL Error Details:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "${{ env.CLOUDSQL_ERROR }}" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ -n "${FULL_ERROR_OUTPUT:-}" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Complete Error Output:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "${{ env.FULL_ERROR_OUTPUT }}" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ -n "${ROLLBACK_ERROR:-}" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### 🚨 CRITICAL - Rollback Failed:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "${{ env.ROLLBACK_ERROR }}" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "**MANUAL INTERVENTION REQUIRED**" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ -n "${SAFETY_ROLLBACK_ERROR:-}" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### 🚨 CRITICAL - Safety Rollback Failed:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "${{ env.SAFETY_ROLLBACK_ERROR }}" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
            
            # Add troubleshooting tips
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🔧 Troubleshooting Tips:" >> $GITHUB_STEP_SUMMARY
            echo "1. Verify CloudSQL instance is running and accessible" >> $GITHUB_STEP_SUMMARY
            echo "2. Check service account permissions for CloudSQL" >> $GITHUB_STEP_SUMMARY
            echo "3. Ensure database exists and credentials are correct" >> $GITHUB_STEP_SUMMARY
            echo "4. Review the specific changeset mentioned in the error" >> $GITHUB_STEP_SUMMARY
            echo "5. Test the SQL manually in CloudSQL console" >> $GITHUB_STEP_SUMMARY
            echo "6. For private IP: Verify VPC and firewall rules" >> $GITHUB_STEP_SUMMARY
            echo "7. For public IP: Check authorized networks" >> $GITHUB_STEP_SUMMARY
          else
            # Success cases
            if [ "${{ steps.lb_update.outcome }}" == "success" ]; then
              echo "- **Result**: ✅ Deployment successful" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ steps.pending_changes.outputs.has_pending_changes }}" == "false" ]; then
              echo "- **Result**: ℹ️ No changes to deploy" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Result**: ⚠️ Deployment skipped" >> $GITHUB_STEP_SUMMARY
            fi
          fi